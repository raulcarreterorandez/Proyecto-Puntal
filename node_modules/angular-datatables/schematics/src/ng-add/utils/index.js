"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSourceFile = exports.addModuleImportToModule = exports.addModuleImportToRootModule = exports.removePackageJsonDependency = exports.addAssetToAngularJson = exports.addPackageToPackageJson = exports.getProjectTargetOptions = exports.expectProjectStyleFile = exports.getProjectFromWorkspace = exports.addStyleToTarget = exports.installPackageJsonDependencies = void 0;
var ts = require("typescript");
var ast_utils_1 = require("@schematics/angular/utility/ast-utils");
var change_1 = require("@schematics/angular/utility/change");
var ng_ast_utils_1 = require("@schematics/angular/utility/ng-ast-utils");
var index_1 = require("@schematics/angular/utility/test/index");
var project_main_file_1 = require("./project-main-file");
var tasks_1 = require("@angular-devkit/schematics/tasks");
var schematics_1 = require("@angular-devkit/schematics");
function installPackageJsonDependencies() {
    return function (host, context) {
        context.addTask(new tasks_1.NodePackageInstallTask());
        context.logger.log('info', "\uD83D\uDD0D Installing packages...");
        return host;
    };
}
exports.installPackageJsonDependencies = installPackageJsonDependencies;
function addStyleToTarget(project, targetName, host, assetPath, workspace) {
    var targetOptions = getProjectTargetOptions(project, targetName);
    if (!targetOptions.styles) {
        targetOptions.styles = [assetPath];
    }
    else {
        var existingStyles = targetOptions.styles
            .map(function (style) {
            return typeof style === 'string' ? style : style.input;
        });
        var hasBootstrapStyle = existingStyles.find(function (style) {
            return style.includes(assetPath);
        });
        if (!hasBootstrapStyle) {
            targetOptions.styles.unshift(assetPath);
        }
    }
    host.overwrite('angular.json', JSON.stringify(workspace, null, 2));
}
exports.addStyleToTarget = addStyleToTarget;
function getProjectFromWorkspace(workspace, projectName) {
    /* tslint:disable-next-line: no-non-null-assertion */
    var project = workspace.projects[projectName || workspace.defaultProject];
    if (!project) {
        throw new Error("Could not find project in workspace: ".concat(projectName));
    }
    return project;
}
exports.getProjectFromWorkspace = getProjectFromWorkspace;
function expectProjectStyleFile(project, filePath) {
    expect(getProjectTargetOptions(project, 'build').styles).toContain(filePath, "Expected \"".concat(filePath, "\" to be added to the project styles in the workspace."));
}
exports.expectProjectStyleFile = expectProjectStyleFile;
function getProjectTargetOptions(project, buildTarget) {
    var targetConfig = project.architect && project.architect[buildTarget] ||
        project.targets && project.targets[buildTarget];
    if (targetConfig && targetConfig.options) {
        return targetConfig.options;
    }
    throw new Error("Cannot determine project target configuration for: ".concat(buildTarget, "."));
}
exports.getProjectTargetOptions = getProjectTargetOptions;
function sortObjectByKeys(obj) {
    return Object
        .keys(obj)
        .sort()
        /* tslint:disable-next-line: no-any */
        .reduce(function (result, key) { return (result[key] = obj[key]) && result; }, {});
}
/**
 * This function has been borrowed from:
 * https://github.com/valor-software/ngx-bootstrap/tree/development/schematics/src/utils/index.ts
 *
 * Note: This function accepts an additional parameter `isDevDependency` so we
 * can place a given dependency in the correct dependencies array inside package.json
 */
function addPackageToPackageJson(host, pkg, version, isDevDependency) {
    if (isDevDependency === void 0) { isDevDependency = false; }
    if (host.exists('package.json')) {
        /* tslint:disable-next-line: no-non-null-assertion */
        var sourceText = host.read('package.json').toString('utf-8');
        var json = JSON.parse(sourceText);
        if (!json.dependencies) {
            json.dependencies = {};
        }
        if (!json.devDependencies) {
            json.dependencies = {};
        }
        // update UI that `pkg` wasn't re-added to package.json
        if (json.dependencies[pkg] || json.devDependencies[pkg])
            return false;
        if (!json.dependencies[pkg] && !isDevDependency) {
            json.dependencies[pkg] = version;
            json.dependencies = sortObjectByKeys(json.dependencies);
        }
        if (!json.devDependencies[pkg] && isDevDependency) {
            json.devDependencies[pkg] = version;
            json.devDependencies = sortObjectByKeys(json.devDependencies);
        }
        host.overwrite('package.json', JSON.stringify(json, null, 2));
        return true;
    }
    return false;
}
exports.addPackageToPackageJson = addPackageToPackageJson;
function addAssetToAngularJson(host, assetType, assetPath) {
    /* tslint:disable-next-line: no-non-null-assertion */
    var sourceText = host.read('angular.json').toString('utf-8');
    var json = JSON.parse(sourceText);
    if (!json)
        return false;
    var projectName = Object.keys(json['projects'])[0];
    var projectObject = json.projects[projectName];
    var targets = projectObject.targets || projectObject.architect;
    var targetLocation = targets.build.options[assetType];
    // update UI that `assetPath` wasn't re-added to angular.json
    if (targetLocation.indexOf(assetPath) != -1)
        return false;
    targetLocation.push(assetPath);
    host.overwrite('angular.json', JSON.stringify(json, null, 2));
    return true;
}
exports.addAssetToAngularJson = addAssetToAngularJson;
function removePackageJsonDependency(tree, dependencyName) {
    var packageContent = JSON.parse((0, index_1.getFileContent)(tree, '/package.json'));
    delete packageContent.dependencies[dependencyName];
    tree.overwrite('/package.json', JSON.stringify(packageContent, null, 2));
}
exports.removePackageJsonDependency = removePackageJsonDependency;
function addModuleImportToRootModule(host, moduleName, src, project) {
    var modulePath = (0, ng_ast_utils_1.getAppModulePath)(host, (0, project_main_file_1.getProjectMainFile)(project));
    addModuleImportToModule(host, modulePath, moduleName, src);
}
exports.addModuleImportToRootModule = addModuleImportToRootModule;
function addModuleImportToModule(host, modulePath, moduleName, src) {
    var moduleSource = getSourceFile(host, modulePath);
    if (!moduleSource) {
        throw new schematics_1.SchematicsException("Module not found: ".concat(modulePath));
    }
    var changes = (0, ast_utils_1.addImportToModule)(moduleSource, modulePath, moduleName, src);
    var recorder = host.beginUpdate(modulePath);
    changes.forEach(function (change) {
        if (change instanceof change_1.InsertChange) {
            recorder.insertLeft(change.pos, change.toAdd);
        }
    });
    host.commitUpdate(recorder);
}
exports.addModuleImportToModule = addModuleImportToModule;
function getSourceFile(host, path) {
    var buffer = host.read(path);
    if (!buffer) {
        throw new schematics_1.SchematicsException("Could not find file for path: ".concat(path));
    }
    var content = buffer.toString();
    return ts.createSourceFile(path, content, ts.ScriptTarget.Latest, true);
}
exports.getSourceFile = getSourceFile;
//# sourceMappingURL=index.js.map